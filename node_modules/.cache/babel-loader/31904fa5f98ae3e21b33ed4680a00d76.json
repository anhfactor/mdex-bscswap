{"ast":null,"code":"import _regeneratorRuntime from\"/Users/lap14205/Documents/home/blockchain_learning/bscswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/Users/lap14205/Documents/home/blockchain_learning/bscswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _asyncToGenerator from\"/Users/lap14205/Documents/home/blockchain_learning/bscswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{createAction,createAsyncThunk}from'@reduxjs/toolkit';import schema from'@uniswap/token-lists/src/tokenlist.schema.json';import Ajv from'ajv';import uriToHttp from'../../utils/uriToHttp';var tokenListValidator=new Ajv({allErrors:true}).compile(schema);/**\n * Contains the logic for resolving a URL to a valid token list\n * @param listUrl list url\n */function getTokenList(_x){return _getTokenList.apply(this,arguments);}function _getTokenList(){_getTokenList=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(listUrl){var urls,_iterator,_step,_url,response,json,_tokenListValidator$e,_tokenListValidator$e2;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:urls=uriToHttp(listUrl);_iterator=_createForOfIteratorHelper(urls);_context.prev=2;_iterator.s();case 4:if((_step=_iterator.n()).done){_context.next=27;break;}_url=_step.value;response=void 0;_context.prev=7;_context.next=10;return fetch(_url);case 10:response=_context.sent;if(response.ok){_context.next=13;break;}return _context.abrupt(\"continue\",25);case 13:_context.next=19;break;case 15:_context.prev=15;_context.t0=_context[\"catch\"](7);console.error(\"failed to fetch list \".concat(listUrl,\" at uri \").concat(_url));return _context.abrupt(\"continue\",25);case 19:_context.next=21;return response.json();case 21:json=_context.sent;if(tokenListValidator(json)){_context.next=24;break;}throw new Error((_tokenListValidator$e=(_tokenListValidator$e2=tokenListValidator.errors)===null||_tokenListValidator$e2===void 0?void 0:_tokenListValidator$e2.reduce(function(memo,error){var _error$message;var add=\"\".concat(error.dataPath,\" \").concat((_error$message=error.message)!==null&&_error$message!==void 0?_error$message:'');return memo.length>0?\"\".concat(memo,\"; \").concat(add):\"\".concat(add);},''))!==null&&_tokenListValidator$e!==void 0?_tokenListValidator$e:'Token list failed validation');case 24:return _context.abrupt(\"return\",json);case 25:_context.next=4;break;case 27:_context.next=32;break;case 29:_context.prev=29;_context.t1=_context[\"catch\"](2);_iterator.e(_context.t1);case 32:_context.prev=32;_iterator.f();return _context.finish(32);case 35:throw new Error('Unrecognized list URL protocol.');case 36:case\"end\":return _context.stop();}}},_callee,null,[[2,29,32,35],[7,15]]);}));return _getTokenList.apply(this,arguments);}var fetchCache={};export var fetchTokenList=createAsyncThunk('lists/fetchTokenList',function(url){var _fetchCache$url;return(// this makes it so we only ever fetch a list a single time concurrently\nfetchCache[url]=(_fetchCache$url=fetchCache[url])!==null&&_fetchCache$url!==void 0?_fetchCache$url:getTokenList(url).catch(function(error){delete fetchCache[url];throw error;}));});export var acceptListUpdate=createAction('lists/acceptListUpdate');export var addList=createAction('lists/addList');export var rejectVersionUpdate=createAction('lists/rejectVersionUpdate');","map":{"version":3,"sources":["/Users/lap14205/Documents/home/blockchain_learning/bscswap-interface/src/state/lists/actions.ts"],"names":["createAction","createAsyncThunk","schema","Ajv","uriToHttp","tokenListValidator","allErrors","compile","getTokenList","listUrl","urls","url","response","fetch","ok","console","error","json","Error","errors","reduce","memo","add","dataPath","message","length","fetchCache","fetchTokenList","catch","acceptListUpdate","addList","rejectVersionUpdate"],"mappings":"skBAAA,OAASA,YAAT,CAAuBC,gBAAvB,KAA+C,kBAA/C,CAEA,MAAOC,CAAAA,MAAP,KAAmB,gDAAnB,CACA,MAAOC,CAAAA,GAAP,KAAgB,KAAhB,CACA,MAAOC,CAAAA,SAAP,KAAsB,uBAAtB,CAEA,GAAMC,CAAAA,kBAAkB,CAAG,GAAIF,CAAAA,GAAJ,CAAQ,CAAEG,SAAS,CAAE,IAAb,CAAR,EAA6BC,OAA7B,CAAqCL,MAArC,CAA3B,CAEA;;;WAIeM,CAAAA,Y,gJAAf,iBAA4BC,OAA5B,2MACQC,IADR,CACeN,SAAS,CAACK,OAAD,CADxB,sCAEoBC,IAFpB,8FAEaC,IAFb,aAGQC,QAHR,+CAKuBC,CAAAA,KAAK,CAACF,IAAD,CAL5B,SAKMC,QALN,kBAMWA,QAAQ,CAACE,EANpB,yJAQMC,OAAO,CAACC,KAAR,gCAAsCP,OAAtC,oBAAwDE,IAAxD,GARN,qEAYuBC,CAAAA,QAAQ,CAACK,IAAT,EAZvB,SAYUA,IAZV,kBAaSZ,kBAAkB,CAACY,IAAD,CAb3B,+BAcY,IAAIC,CAAAA,KAAJ,gDACJb,kBAAkB,CAACc,MADf,iDACJ,uBAA2BC,MAA3B,CAA0C,SAACC,IAAD,CAAOL,KAAP,CAAiB,oBACzD,GAAMM,CAAAA,GAAG,WAAMN,KAAK,CAACO,QAAZ,6BAAwBP,KAAK,CAACQ,OAA9B,iDAAyC,EAAzC,CAAT,CACA,MAAOH,CAAAA,IAAI,CAACI,MAAL,CAAc,CAAd,WAAqBJ,IAArB,cAA8BC,GAA9B,YAAyCA,GAAzC,CAAP,CACD,CAHD,CAGG,EAHH,CADI,+DAIM,8BAJN,CAdZ,yCAqBWL,IArBX,iOAuBQ,IAAIC,CAAAA,KAAJ,CAAU,iCAAV,CAvBR,mF,+CA0BA,GAAMQ,CAAAA,UAAiD,CAAG,EAA1D,CACA,MAAO,IAAMC,CAAAA,cAAc,CAAG1B,gBAAgB,CAC5C,sBAD4C,CAE5C,SAACU,GAAD,4BACE;AACCe,UAAU,CAACf,GAAD,CAAV,kBACCe,UAAU,CAACf,GAAD,CADX,mDAECH,YAAY,CAACG,GAAD,CAAZ,CAAkBiB,KAAlB,CAAwB,SAAAZ,KAAK,CAAI,CAC/B,MAAOU,CAAAA,UAAU,CAACf,GAAD,CAAjB,CACA,KAAMK,CAAAA,KAAN,CACD,CAHD,CAJJ,GAF4C,CAAvC,CAYP,MAAO,IAAMa,CAAAA,gBAAgB,CAAG7B,YAAY,CAAS,wBAAT,CAArC,CACP,MAAO,IAAM8B,CAAAA,OAAO,CAAG9B,YAAY,CAAS,eAAT,CAA5B,CACP,MAAO,IAAM+B,CAAAA,mBAAmB,CAAG/B,YAAY,CAAU,2BAAV,CAAxC","sourcesContent":["import { createAction, createAsyncThunk } from '@reduxjs/toolkit'\nimport { TokenList, Version } from '@uniswap/token-lists'\nimport schema from '@uniswap/token-lists/src/tokenlist.schema.json'\nimport Ajv from 'ajv'\nimport uriToHttp from '../../utils/uriToHttp'\n\nconst tokenListValidator = new Ajv({ allErrors: true }).compile(schema)\n\n/**\n * Contains the logic for resolving a URL to a valid token list\n * @param listUrl list url\n */\nasync function getTokenList(listUrl: string): Promise<TokenList> {\n  const urls = uriToHttp(listUrl)\n  for (const url of urls) {\n    let response\n    try {\n      response = await fetch(url)\n      if (!response.ok) continue\n    } catch (error) {\n      console.error(`failed to fetch list ${listUrl} at uri ${url}`)\n      continue\n    }\n\n    const json = await response.json()\n    if (!tokenListValidator(json)) {\n      throw new Error(\n        tokenListValidator.errors?.reduce<string>((memo, error) => {\n          const add = `${error.dataPath} ${error.message ?? ''}`\n          return memo.length > 0 ? `${memo}; ${add}` : `${add}`\n        }, '') ?? 'Token list failed validation'\n      )\n    }\n    return json\n  }\n  throw new Error('Unrecognized list URL protocol.')\n}\n\nconst fetchCache: { [url: string]: Promise<TokenList> } = {}\nexport const fetchTokenList = createAsyncThunk<TokenList, string>(\n  'lists/fetchTokenList',\n  (url: string) =>\n    // this makes it so we only ever fetch a list a single time concurrently\n    (fetchCache[url] =\n      fetchCache[url] ??\n      getTokenList(url).catch(error => {\n        delete fetchCache[url]\n        throw error\n      }))\n)\n\nexport const acceptListUpdate = createAction<string>('lists/acceptListUpdate')\nexport const addList = createAction<string>('lists/addList')\nexport const rejectVersionUpdate = createAction<Version>('lists/rejectVersionUpdate')\n"]},"metadata":{},"sourceType":"module"}