{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\n\nvar n = require(\"@web3-react/abstract-connector\");\n\nfunction e() {\n  return (e = Object.assign || function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n\n      for (var r in t) {\n        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);\n      }\n    }\n\n    return n;\n  }).apply(this, arguments);\n}\n\nfunction t(n, e) {\n  n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e;\n}\n\nfunction r(n) {\n  return (r = Object.setPrototypeOf ? Object.getPrototypeOf : function (n) {\n    return n.__proto__ || Object.getPrototypeOf(n);\n  })(n);\n}\n\nfunction i(n, e) {\n  return (i = Object.setPrototypeOf || function (n, e) {\n    return n.__proto__ = e, n;\n  })(n, e);\n}\n\nfunction o() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (n) {\n    return !1;\n  }\n}\n\nfunction a(n, e, t) {\n  return (a = o() ? Reflect.construct : function (n, e, t) {\n    var r = [null];\n    r.push.apply(r, e);\n    var o = new (Function.bind.apply(n, r))();\n    return t && i(o, t.prototype), o;\n  }).apply(null, arguments);\n}\n\nfunction c(n) {\n  var e = \"function\" == typeof Map ? new Map() : void 0;\n  return (c = function c(n) {\n    if (null === n || -1 === Function.toString.call(n).indexOf(\"[native code]\")) return n;\n    if (\"function\" != typeof n) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== e) {\n      if (e.has(n)) return e.get(n);\n      e.set(n, t);\n    }\n\n    function t() {\n      return a(n, arguments, r(this).constructor);\n    }\n\n    return t.prototype = Object.create(n.prototype, {\n      constructor: {\n        value: t,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), i(t, n);\n  })(n);\n}\n\nfunction u(n) {\n  if (void 0 === n) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return n;\n}\n\nfunction h(n, e) {\n  try {\n    var t = n();\n  } catch (n) {\n    return e(n);\n  }\n\n  return t && t.then ? t.then(void 0, e) : t;\n}\n\nfunction s(n) {\n  return n.hasOwnProperty(\"result\") ? n.result : n;\n}\n\nrequire(\"tiny-warning\"), \"undefined\" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))), \"undefined\" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")));\n\nvar d = function (n) {\n  function e() {\n    var e;\n    return (e = n.call(this) || this).name = e.constructor.name, e.message = \"No Binance Wallet provider was found on window.BinanceChain.\", e;\n  }\n\n  return t(e, n), e;\n}(c(Error)),\n    f = function (n) {\n  function e() {\n    var e;\n    return (e = n.call(this) || this).name = e.constructor.name, e.message = \"The user rejected the request.\", e;\n  }\n\n  return t(e, n), e;\n}(c(Error));\n\nexports.BinanceConnector = function (n) {\n  function r(e) {\n    var t;\n    return (t = n.call(this, e) || this).handleNetworkChanged = t.handleNetworkChanged.bind(u(t)), t.handleChainChanged = t.handleChainChanged.bind(u(t)), t.handleAccountsChanged = t.handleAccountsChanged.bind(u(t)), t.handleClose = t.handleClose.bind(u(t)), t;\n  }\n\n  t(r, n);\n  var i = r.prototype;\n  return i.handleChainChanged = function (n) {\n    this.emitUpdate({\n      chainId: n,\n      provider: window.BinanceChain\n    });\n  }, i.handleAccountsChanged = function (n) {\n    0 === n.length ? this.emitDeactivate() : this.emitUpdate({\n      account: n[0]\n    });\n  }, i.handleClose = function (n, e) {\n    this.emitDeactivate();\n  }, i.handleNetworkChanged = function (n) {\n    this.emitUpdate({\n      chainId: n,\n      provider: window.BinanceChain\n    });\n  }, i.activate = function () {\n    try {\n      var n,\n          t = function t(_t) {\n        if (r) return _t;\n\n        function i() {\n          return e({\n            provider: window.BinanceChain\n          }, n ? {\n            account: n\n          } : {});\n        }\n\n        var o = function () {\n          if (!n) return Promise.resolve(window.BinanceChain.enable().then(function (n) {\n            return n && s(n)[0];\n          })).then(function (e) {\n            n = e;\n          });\n        }();\n\n        return o && o.then ? o.then(i) : i();\n      },\n          r = !1;\n\n      if (!window.BinanceChain) throw new d();\n      window.BinanceChain.on && (window.BinanceChain.on(\"chainChanged\", this.handleChainChanged), window.BinanceChain.on(\"accountsChanged\", this.handleAccountsChanged), window.BinanceChain.on(\"close\", this.handleClose), window.BinanceChain.on(\"networkChanged\", this.handleNetworkChanged));\n      var i = h(function () {\n        return Promise.resolve(window.BinanceChain.send(\"eth_requestAccounts\").then(function (n) {\n          return s(n)[0];\n        })).then(function (e) {\n          n = e;\n        });\n      }, function (n) {\n        if (4001 === n.code) throw new f();\n      });\n      return Promise.resolve(i && i.then ? i.then(t) : t(i));\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, i.getProvider = function () {\n    try {\n      return Promise.resolve(window.BinanceChain);\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, i.getChainId = function () {\n    try {\n      var n,\n          e = function e() {\n        function e() {\n          if (!n) try {\n            n = s(window.BinanceChain.send({\n              method: \"net_version\"\n            }));\n          } catch (n) {}\n          return n || (n = window.BinanceChain.isDapper ? s(window.BinanceChain.cachedResults.net_version) : window.BinanceChain.chainId || window.BinanceChain.netVersion || window.BinanceChain.networkVersion || window.BinanceChain._chainId), n;\n        }\n\n        var t = function () {\n          if (!n) {\n            var e = h(function () {\n              return Promise.resolve(window.BinanceChain.send(\"net_version\").then(s)).then(function (e) {\n                n = e;\n              });\n            }, function () {});\n            if (e && e.then) return e.then(function () {});\n          }\n        }();\n\n        return t && t.then ? t.then(e) : e();\n      };\n\n      if (!window.BinanceChain) throw new d();\n      var t = h(function () {\n        return Promise.resolve(window.BinanceChain.send(\"eth_chainId\").then(s)).then(function (e) {\n          n = e;\n        });\n      }, function () {});\n      return Promise.resolve(t && t.then ? t.then(e) : e());\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, i.getAccount = function () {\n    try {\n      var n,\n          e = function e() {\n        function e() {\n          return n || (n = s(window.BinanceChain.send({\n            method: \"eth_accounts\"\n          }))[0]), n;\n        }\n\n        var t = function () {\n          if (!n) {\n            var e = h(function () {\n              return Promise.resolve(window.BinanceChain.enable().then(function (n) {\n                return s(n)[0];\n              })).then(function (e) {\n                n = e;\n              });\n            }, function () {});\n            if (e && e.then) return e.then(function () {});\n          }\n        }();\n\n        return t && t.then ? t.then(e) : e();\n      };\n\n      if (!window.BinanceChain) throw new d();\n      var t = h(function () {\n        return Promise.resolve(window.BinanceChain.send(\"eth_accounts\").then(function (n) {\n          return s(n)[0];\n        })).then(function (e) {\n          n = e;\n        });\n      }, function () {});\n      return Promise.resolve(t && t.then ? t.then(e) : e());\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, i.deactivate = function () {\n    window.BinanceChain && window.BinanceChain.removeListener && (window.BinanceChain.removeListener(\"chainChanged\", this.handleChainChanged), window.BinanceChain.removeListener(\"accountsChanged\", this.handleAccountsChanged), window.BinanceChain.removeListener(\"close\", this.handleClose), window.BinanceChain.removeListener(\"networkChanged\", this.handleNetworkChanged));\n  }, i.isAuthorized = function () {\n    try {\n      return window.BinanceChain ? Promise.resolve(h(function () {\n        return Promise.resolve(window.BinanceChain.send(\"eth_accounts\").then(function (n) {\n          return s(n).length > 0;\n        }));\n      }, function () {\n        return !1;\n      })) : Promise.resolve(!1);\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, r;\n}(n.AbstractConnector), exports.NoEthereumProviderError = d, exports.UserRejectedRequestError = f;","map":{"version":3,"sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/index.ts"],"names":["Symbol","iterator","asyncIterator","_catch","body","recover","result","e","then","parseSendReturn","sendReturn","hasOwnProperty","NoEthereumProviderError","Error","name","_this","constructor","message","UserRejectedRequestError","_this2","AbstractConnector","kwargs","handleNetworkChanged","_this3","bind","handleChainChanged","handleAccountsChanged","handleClose","chainId","emitUpdate","provider","window","BinanceChain","accounts","length","emitDeactivate","account","code","reason","networkId","activate","on","this","send","error","enable","getProvider","getChainId","method","isDapper","cachedResults","net_version","netVersion","networkVersion","_chainId","getAccount","deactivate","removeListener","isAuthorized"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkjBO;;AAAA,SAASG,CAAT,CAAgBC,CAAhB,EAAsBC,CAAtB,EAAsBA;AAC5B,MAAA;AACC,QAAIC,CAAAA,GAASF,CAAAA,EAAb;AACC,GAFF,CAEE,OAAMG,CAAN,EAAMA;AACP,WAAOF,CAAAA,CAAQE,CAARF,CAAP;AAED;;AAAA,SAAIC,CAAAA,IAAUA,CAAAA,CAAOE,IAAjBF,GACIA,CAAAA,CAAOE,IAAPF,CAAOE,KAAK,CAAZF,EAAoBD,CAApBC,CADJA,GAGGA,CAHP;ACljBD;;AAAA,SAASG,CAAT,CAAyBC,CAAzB,EAAyBA;AAAAA,SAChBA,CAAAA,CAAWC,cAAXD,CAA0B,QAA1BA,IAAsCA,CAAAA,CAAWJ,MAAjDI,GAA0DA,CAD1CA;AAC0CA;;AAAAA,OAAAA,CAAAA,cAAAA,CAAAA,ED6JJ,eAAA,OAAXV,MAAW,KAAeA,MAAAA,CAAOC,QAAPD,KAAoBA,MAAAA,CAAOC,QAAPD,GAAkBA,MAAAA,CAAO,iBAAPA,CAAtCA,CAAf,CC7JIU,ED0NC,eAAA,OAAXV,MAAW,KAAeA,MAAAA,CAAOE,aAAPF,KAAyBA,MAAAA,CAAOE,aAAPF,GAAuBA,MAAAA,CAAO,sBAAPA,CAAhDA,CAAf,CC1NDU;;AD0NuE,ICvN7HE,CAAAA,GAAAA,UAAAA,CAAAA,EAAAA;AAAAA,WAAAA,CAAAA,GAAAA;AAAAA,QAAAA,CAAAA;AAAAA,WAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,IAAAA,KAAAA,IAAAA,EAGJE,IAHIF,GAGGG,CAAAA,CAAKC,WAALD,CAAiBD,IAHpBF,EAGoBE,CAAAA,CACxBG,OADwBH,GACd,8DAJNF,EAIM,CAJNA;AAIM;;AAAA,SAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA;AAAA,CAJNA,CAIM,CAAA,CAJ0BC,KAI1B,CAJND,CDuN6H;AAAA,IC/M7HM,CAAAA,GAAAA,UAAAA,CAAAA,EAAAA;AAAAA,WAAAA,CAAAA,GAAAA;AAAAA,QAAAA,CAAAA;AAAAA,WAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,IAAAA,KAAAA,IAAAA,EAGJJ,IAHII,GAGGC,CAAAA,CAAKH,WAALG,CAAiBL,IAHpBI,EAGoBJ,CAAAA,CACxBG,OADwBH,GACd,gCAJNI,EAIM,CAJNA;AAIM;;AAAA,SAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAA;AAAA,CAJNA,CAIM,CAAA,CAJ2BL,KAI3B,CAJNK,CD+M6H;;AC/M5FL,OAAAA,CAAAA,gBAAAA,GAAAA,UAAAA,CAAAA,EAAAA;AAAAA,WAAAA,CAAAA,CAShCQ,CATgCR,EAShCQ;AAAAA,QAAAA,CAAAA;AAAAA,WAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EACJA,CADIA,KACJA,IADIA,EAGLC,oBAHKD,GAGkBE,CAAAA,CAAKD,oBAALC,CAA0BC,IAA1BD,CAA0BC,CAAAA,CAAAA,CAAAA,CAA1BD,CAHlBF,EAG4CG,CAAAA,CACjDC,kBADiDD,GAC5BD,CAAAA,CAAKE,kBAALF,CAAwBC,IAAxBD,CAAwBC,CAAAA,CAAAA,CAAAA,CAAxBD,CAJhBF,EAIwCG,CAAAA,CAC7CE,qBAD6CF,GACrBD,CAAAA,CAAKG,qBAALH,CAA2BC,IAA3BD,CAA2BC,CAAAA,CAAAA,CAAAA,CAA3BD,CALnBF,EAK8CG,CAAAA,CACnDG,WADmDH,GACrCD,CAAAA,CAAKI,WAALJ,CAAiBC,IAAjBD,CAAiBC,CAAAA,CAAAA,CAAAA,CAAjBD,CANTF,EAM0BG,CAN1BH;AAM0BG;;AAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA;AAAAA,MAAAA,CAAAA,GAAAA,CAAAA,CAAAA,SAAAA;AAAAA,SAAAA,CAAAA,CAG9BC,kBAH8BD,GAG9BC,UAAmBG,CAAnBH,EAAmBG;AAAAA,SAIpBC,UAJoBD,CAIT;AAAEA,MAAAA,OAAAA,EAAAA,CAAF;AAAWE,MAAAA,QAAAA,EAAUC,MAAAA,CAAOC;AAA5B,KAJSJ;AAImBI,GAPRR,EAOQQ,CAAAA,CAGtCN,qBAHsCM,GAGtCN,UAAsBO,CAAtBP,EAAsBO;AAIJ,UAApBA,CAAAA,CAASC,MAAW,GAAXA,KACNC,cADMD,EAAW,GACjBC,KAEAN,UAFAM,CAEW;AAAEC,MAAAA,OAAAA,EAASH,CAAAA,CAAS,CAATA;AAAX,KAFXE,CADiB;AAGc,GAjBFX,EAiBE,CAAA,CAIhCG,WAJgC,GAIhCA,UAAYU,CAAZV,EAA0BW,CAA1BX,EAA0BW;AAAAA,SAI3BH,cAJ2BG;AAI3BH,GAzB+BX,EAyB/BW,CAAAA,CAGCb,oBAHDa,GAGCb,UAAqBiB,CAArBjB,EAAqBiB;AAAAA,SAItBV,UAJsBU,CAIX;AAAEX,MAAAA,OAAAA,EAASW,CAAX;AAAsBT,MAAAA,QAAAA,EAAUC,MAAAA,CAAOC;AAAvC,KAJWO;AAI4BP,GAhCnBR,EAgCmBQ,CAAAA,CAG5CQ,QAH4CR,GAG5CQ,YAAAA;AAAAA,QAAAA;AAAAA,UAaPJ,CAbOI;AAAAA,UAaPJ,CAAAA,GAAAA,WAAAA,EAAAA,EAAAA;AAAAA,YAAAA,CAAAA,EAAAA,OAAAA,EAAAA;;AAAAA,iBAAAA,CAAAA,GAAAA;AAAAA,iBAAAA,CAAAA,CAAAA;AAkBKN,YAAAA,QAAAA,EAAUC,MAAAA,CAAOC;AAlBtBI,WAAAA,EAkBwCA,CAAAA,GAAU;AAAEA,YAAAA,OAAAA,EAAAA;AAAF,WAAVA,GAAwB,EAlBhEA,CAAAA;AAkBgE;;AAAA,YAAA,CAAA,GAAA,YAAA;AAAA,cAAA,CAL/DA,CAK+D,EAL/DA,OAAAA,OAAAA,CAAAA,OAAAA,CAEaL,MAAAA,CAAOC,YAAPD,CAAoBc,MAApBd,GAA6BvB,IAA7BuB,CAAkC,UAAA,CAAA,EAAA;AAAA,mBAAcrB,CAAAA,IAAcD,CAAAA,CAAgBC,CAAhBD,CAAAA,CAA4B,CAA5BA,CAA5B;AAAwD,WAA1FsB,CAFbK,EAEuG,IAFvGA,CAEuG,UAAA,CAAA,EAAA;AAA1GA,YAAAA,CAAAA,GAAAA,CAAAA;AAAAA,WAFGA,CAAAA;AAEHA,SAGkE,EAAA;;AAHlEA,eAAAA,CAAAA,IAAAA,CAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA;AAAAA,OA5BSI;AAAAA,UA4BTJ,CAAAA,GAAAA,CAAAA,CA5BSI;;AA4BTJ,UAAAA,CA3BGL,MAAAA,CAAOC,YA2BVI,EA3BUJ,MACJ,IAAIpB,CAAJ,EADIoB;AAIRD,MAAAA,MAAAA,CAAOC,YAAPD,CAAoBU,EAApBV,KACFA,MAAAA,CAAOC,YAAPD,CAAoBU,EAApBV,CAAuB,cAAvBA,EAAuCW,KAAKjB,kBAA5CM,GACAA,MAAAA,CAAOC,YAAPD,CAAoBU,EAApBV,CAAuB,iBAAvBA,EADuCW,KACQhB,qBAA/CK,CADAA,EAEAA,MAAAA,CAAOC,YAAPD,CAAoBU,EAApBV,CAAuB,OAAvBA,EAFuCW,KAEFf,WAArCI,CAFAA,EAGAA,MAAAA,CAAOC,YAAPD,CAAoBU,EAApBV,CAAuB,gBAAvBA,EAHuCW,KAGOpB,oBAA9CS,CAJEA;AAI4CT,UAAAA,CAAAA,GAAAA,CAAAA,CAAAA,YAAAA;AAAAA,eAAAA,OAAAA,CAAAA,OAAAA,CAM7BS,MAAAA,CAAOC,YAAPD,CAAoBY,IAApBZ,CAAkC,qBAAlCA,EAAyDvB,IAAzDuB,CACf,UAAA,CAAA,EAAA;AAAA,iBAActB,CAAAA,CAAgBC,CAAhBD,CAAAA,CAA4B,CAA5BA,CAAd;AAA0C,SAD3BsB,CAN6BT,EAOF,IAPEA,CAOF,UAAA,CAAA,EAAA;AAD5Cc,UAAAA,CAAAA,GAAAA,CAAAA;AAAAA,SAN8Cd,CAAAA;AAM9Cc,OAN8Cd,EAM9Cc,UAGOQ,CAHPR,EAGOQ;AAAAA,YACqB,SAAvBA,CAAAA,CAAcP,IADZO,EACYP,MACX,IAAInB,CAAJ,EADWmB;AACPnB,OAXkCI,CAAAA;AAWlCJ,aAAAA,OAAAA,CAAAA,OAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA;AAAAA,KApBHsB,CAoBGtB,OAAAA,CAAAA,EAAAA;AAAAA,aAAAA,OAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA;AAAAA;AAAAA,GAvDsBM,EAuDtBN,CAAAA,CAcH4B,WAdG5B,GAcH4B,YAAAA;AAAAA,QAAAA;AAAAA,aAAAA,OAAAA,CAAAA,OAAAA,CACJf,MAAAA,CAAOC,YADHc,CAAAA;AACGd,KADHc,CACGd,OAAAA,CAAAA,EAAAA;AAAAA,aAAAA,OAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA;AAAAA;AAAAA,GAtEsBR,EAsEtBQ,CAAAA,CAGHe,UAHGf,GAGHe,YAAAA;AAAAA,QAAAA;AAAAA,UAKPnB,CALOmB;AAAAA,UAKPnB,CAAAA,GAAAA,aAAAA;AAAAA,iBAAAA,CAAAA,GAAAA;AAAAA,cAAAA,CAeCA,CAfDA,EAeCA,IAAAA;AAEDA,YAAAA,CAAAA,GAAUnB,CAAAA,CAAiBsB,MAAAA,CAAOC,YAAPD,CAAoBY,IAApBZ,CAAqC;AAAEiB,cAAAA,MAAAA,EAAQ;AAAV,aAArCjB,CAAjBtB,CAAVmB;AACA,WAHCA,CAGD,OAAA,CAAA,EAAA,CAAA;AAAA,iBAKCA,CAAAA,KAEDA,CAAAA,GADGG,MAAAA,CAAOC,YAAPD,CAA4BkB,QAA5BlB,GACOtB,CAAAA,CAAiBsB,MAAAA,CAAOC,YAAPD,CAA4BmB,aAA5BnB,CAA0CoB,WAA3D1C,CADPsB,GAIAA,MAAAA,CAAOC,YAAPD,CAA4BH,OAA5BG,IACAA,MAAAA,CAAOC,YAAPD,CAA4BqB,UAD5BrB,IAEAA,MAAAA,CAAOC,YAAPD,CAA4BsB,cAF5BtB,IAGAA,MAAAA,CAAOC,YAAPD,CAA4BuB,QAR9B1B,CAAAA,EAYEA,CAjBH;AAiBGA;;AAAAA,YAAAA,CAAAA,GAAAA,YAAAA;AAAAA,cAAAA,CA5BFA,CA4BEA,EA5BFA;AAAAA,gBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,YAAAA;AAAAA,qBAAAA,OAAAA,CAAAA,OAAAA,CAEgBG,MAAAA,CAAOC,YAAPD,CAAoBY,IAApBZ,CAAkC,aAAlCA,EAAiDvB,IAAjDuB,CAAsDtB,CAAtDsB,CAFhBH,EAEsEnB,IAFtEmB,CAEsEnB,UAAAA,CAAAA,EAAAA;AAAvEmB,gBAAAA,CAAAA,GAAAA,CAAAA;AAAAA,eAFCA,CAAAA;AAEDA,aAFCA,EAEDA,YAAAA,CAAAA,CAFCA,CAAAA;AAEDA,gBAAAA,CAAAA,IAAAA,CAAAA,CAAAA,IAAAA,EAAAA,OAAAA,CAAAA,CAAAA,IAAAA,CAAAA,YAAAA,CAAAA,CAAAA,CAAAA;AAAAA;AAAAA,SA0BGA,EAAAA;;AA1BHA,eAAAA,CAAAA,IAAAA,CAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA;AAAAA,OAdOmB;;AAcPnB,UAAAA,CAbCG,MAAAA,CAAOC,YAaRJ,EAbQI,MACJ,IAAIpB,CAAJ,EADIoB;AACApB,UAAAA,CAAAA,GAAAA,CAAAA,CAAAA,YAAAA;AAAAA,eAAAA,OAAAA,CAAAA,OAAAA,CAKOmB,MAAAA,CAAOC,YAAPD,CAAoBY,IAApBZ,CAAkC,aAAlCA,EAAiDvB,IAAjDuB,CAAsDtB,CAAtDsB,CALPnB,EAK6DH,IAL7DG,CAK6DH,UAAAA,CAAAA,EAAAA;AAAvEmB,UAAAA,CAAAA,GAAAA,CAAAA;AAAAA,SALUhB,CAAAA;AAKVgB,OALUhB,EAKVgB,YAAAA,CAAAA,CALUhB,CAAAA;AAKVgB,aAAAA,OAAAA,CAAAA,OAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA;AAAAA,KAPSmB,CAOTnB,OAAAA,CAAAA,EAAAA;AAAAA,aAAAA,OAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA;AAAAA;AAAAA,GAhFkCJ,EAgFlCI,CAAAA,CAoCS2B,UApCT3B,GAoCS2B,YAAAA;AAAAA,QAAAA;AAAAA,UAKPnB,CALOmB;AAAAA,UAKPnB,CAAAA,GAAAA,aAAAA;AAAAA,iBAAAA,CAAAA,GAAAA;AAAAA,iBAeCA,CAAAA,KACHA,CAAAA,GAAU3B,CAAAA,CAAiBsB,MAAAA,CAAOC,YAAPD,CAAoBY,IAApBZ,CAAqC;AAAEiB,YAAAA,MAAAA,EAAQ;AAAV,WAArCjB,CAAjBtB,CAAAA,CAAmF,CAAnFA,CADP2B,CAAAA,EAIEA,CAnBHA;AAmBGA;;AAAAA,YAAAA,CAAAA,GAAAA,YAAAA;AAAAA,cAAAA,CAZFA,CAYEA,EAZFA;AAAAA,gBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,YAAAA;AAAAA,qBAAAA,OAAAA,CAAAA,OAAAA,CAEeL,MAAAA,CAAOC,YAAPD,CAAoBc,MAApBd,GAA6BvB,IAA7BuB,CAAkC,UAAA,CAAA,EAAA;AAAA,uBAActB,CAAAA,CAAgBC,CAAhBD,CAAAA,CAA4B,CAA5BA,CAAd;AAA0C,eAA5EsB,CAFfK,EAE2F,IAF3FA,CAE2F,UAAA,CAAA,EAAA;AAA5FA,gBAAAA,CAAAA,GAAAA,CAAAA;AAAAA,eAFCA,CAAAA;AAEDA,aAFCA,EAEDA,YAAAA,CAAAA,CAFCA,CAAAA;AAEDA,gBAAAA,CAAAA,IAAAA,CAAAA,CAAAA,IAAAA,EAAAA,OAAAA,CAAAA,CAAAA,IAAAA,CAAAA,YAAAA,CAAAA,CAAAA,CAAAA;AAAAA;AAAAA,SAUGA,EAAAA;;AAVHA,eAAAA,CAAAA,IAAAA,CAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA;AAAAA,OAdOmB;;AAcPnB,UAAAA,CAbCL,MAAAA,CAAOC,YAaRI,EAbQJ,MACJ,IAAIpB,CAAJ,EADIoB;AACApB,UAAAA,CAAAA,GAAAA,CAAAA,CAAAA,YAAAA;AAAAA,eAAAA,OAAAA,CAAAA,OAAAA,CAKOmB,MAAAA,CAAOC,YAAPD,CAAoBY,IAApBZ,CAAkC,cAAlCA,EAAkDvB,IAAlDuB,CAAuD,UAAA,CAAA,EAAA;AAAA,iBAActB,CAAAA,CAAgBC,CAAhBD,CAAAA,CAA4B,CAA5BA,CAAd;AAA0C,SAAjGsB,CALPnB,EAKwG,IALxGA,CAKwG,UAAA,CAAA,EAAA;AAAlHwB,UAAAA,CAAAA,GAAAA,CAAAA;AAAAA,SALUxB,CAAAA;AAKVwB,OALUxB,EAKVwB,YAAAA,CAAAA,CALUxB,CAAAA;AAKVwB,aAAAA,OAAAA,CAAAA,OAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,IAAAA,GAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA;AAAAA,KAPSmB,CAOTnB,OAAAA,CAAAA,EAAAA;AAAAA,aAAAA,OAAAA,CAAAA,MAAAA,CAAAA,CAAAA,CAAAA;AAAAA;AAAAA,GA3HkCZ,EA2HlCY,CAAAA,CAoBGoB,UApBHpB,GAoBGoB,YAAAA;AACDzB,IAAAA,MAAAA,CAAOC,YAAPD,IAAuBA,MAAAA,CAAOC,YAAPD,CAAoB0B,cAA3C1B,KACFA,MAAAA,CAAOC,YAAPD,CAAoB0B,cAApB1B,CAAmC,cAAnCA,EAAmDW,KAAKjB,kBAAxDM,GACAA,MAAAA,CAAOC,YAAPD,CAAoB0B,cAApB1B,CAAmC,iBAAnCA,EAAsDW,KAAKhB,qBAA3DK,CADAA,EAEAA,MAAAA,CAAOC,YAAPD,CAAoB0B,cAApB1B,CAAmC,OAAnCA,EAA4CW,KAAKf,WAAjDI,CAFAA,EAGAA,MAAAA,CAAOC,YAAPD,CAAoB0B,cAApB1B,CAAmC,gBAAnCA,EAAqDW,KAAKpB,oBAA1DS,CAJEA;AAIwDT,GApJxBE,EAoJwBF,CAAAA,CAIjDoC,YAJiDpC,GAIjDoC,YAAAA;AAAAA,QAAAA;AAAAA,aACN3B,MAAAA,CAAOC,YAAPD,GAAOC,OAAAA,CAAAA,OAAAA,CAAAA,CAAAA,CAAAA,YAAAA;AAAAA,eAAAA,OAAAA,CAAAA,OAAAA,CAKID,MAAAA,CAAOC,YAAPD,CAAoBY,IAApBZ,CAAkC,cAAlCA,EAAkDvB,IAAlDuB,CAAuD,UAAA,CAAA,EAAA;AAAA,iBAC/DtB,CAAAA,CAAgBC,CAAhBD,CAAAA,CAA4ByB,MAA5BzB,GAAqC,CAD0B;AAC1B,SAD7BsB,CALJC,CAAAA;AAMiC,OANjCA,EAMiC,YAAA;AAAA,eAAA,CAOpC,CAPoC;AAOpC,OAbGA,CAAAA,CAAPD,GAaI,OAAA,CAAA,OAAA,CAAA,CAZA,CAYA,CAdE2B;AAEF,KAFEA,CAEF,OAAA,CAAA,EAAA;AAAA,aAAA,OAAA,CAAA,MAAA,CAAA,CAAA,CAAA;AAAA;AAAA,GA1J2BlC,EA0J3B,CA1J2BA;AA0J3B,CAzKiCX,CAQRO,CAAAA,CAAAA,iBARQP,CAAAA,EAQRO,OAAAA,CAAAA,uBAAAA,GAAAA,CARQP,EAQRO,OAAAA,CAAAA,wBAAAA,GAAAA,CARQP","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { AbstractConnectorArguments, ConnectorUpdate } from '@web3-react/types'\r\nimport { AbstractConnector } from '@web3-react/abstract-connector'\r\nimport warning from 'tiny-warning'\r\n\r\nimport { SendReturnResult, SendReturn, Send, SendOld } from './types'\r\n\r\nfunction parseSendReturn(sendReturn: SendReturnResult | SendReturn): any {\r\n  return sendReturn.hasOwnProperty('result') ? sendReturn.result : sendReturn\r\n}\r\n\r\nexport class NoEthereumProviderError extends Error {\r\n  public constructor() {\r\n    super()\r\n    this.name = this.constructor.name\r\n    this.message = 'No Binance Wallet provider was found on window.BinanceChain.'\r\n  }\r\n}\r\n\r\nexport class UserRejectedRequestError extends Error {\r\n  public constructor() {\r\n    super()\r\n    this.name = this.constructor.name\r\n    this.message = 'The user rejected the request.'\r\n  }\r\n}\r\n\r\nexport class BinanceConnector extends AbstractConnector {\r\n  constructor(kwargs: AbstractConnectorArguments) {\r\n    super(kwargs)\r\n\r\n    this.handleNetworkChanged = this.handleNetworkChanged.bind(this)\r\n    this.handleChainChanged = this.handleChainChanged.bind(this)\r\n    this.handleAccountsChanged = this.handleAccountsChanged.bind(this)\r\n    this.handleClose = this.handleClose.bind(this)\r\n  }\r\n\r\n  private handleChainChanged(chainId: string | number): void {\r\n    if (__DEV__) {\r\n      console.log(\"Handling 'chainChanged' event with payload\", chainId)\r\n    }\r\n    this.emitUpdate({ chainId, provider: window.BinanceChain })\r\n  }\r\n\r\n  private handleAccountsChanged(accounts: string[]): void {\r\n    if (__DEV__) {\r\n      console.log(\"Handling 'accountsChanged' event with payload\", accounts)\r\n    }\r\n    if (accounts.length === 0) {\r\n      this.emitDeactivate()\r\n    } else {\r\n      this.emitUpdate({ account: accounts[0] })\r\n    }\r\n  }\r\n\r\n  private handleClose(code: number, reason: string): void {\r\n    if (__DEV__) {\r\n      console.log(\"Handling 'close' event with payload\", code, reason)\r\n    }\r\n    this.emitDeactivate()\r\n  }\r\n\r\n  private handleNetworkChanged(networkId: string | number): void {\r\n    if (__DEV__) {\r\n      console.log(\"Handling 'networkChanged' event with payload\", networkId)\r\n    }\r\n    this.emitUpdate({ chainId: networkId, provider: window.BinanceChain })\r\n  }\r\n\r\n  public async activate(): Promise<ConnectorUpdate> {\r\n    if (!window.BinanceChain) {\r\n      throw new NoEthereumProviderError()\r\n    }\r\n\r\n    if (window.BinanceChain.on) {\r\n      window.BinanceChain.on('chainChanged', this.handleChainChanged)\r\n      window.BinanceChain.on('accountsChanged', this.handleAccountsChanged)\r\n      window.BinanceChain.on('close', this.handleClose)\r\n      window.BinanceChain.on('networkChanged', this.handleNetworkChanged)\r\n    }\r\n\r\n    // try to activate + get account via eth_requestAccounts\r\n    let account\r\n    try {\r\n      account = await (window.BinanceChain.send as Send)('eth_requestAccounts').then(\r\n        sendReturn => parseSendReturn(sendReturn)[0]\r\n      )\r\n    } catch (error) {\r\n      if ((error as any).code === 4001) {\r\n        throw new UserRejectedRequestError()\r\n      }\r\n      warning(false, 'eth_requestAccounts was unsuccessful, falling back to enable')\r\n    }\r\n\r\n    // if unsuccessful, try enable\r\n    if (!account) {\r\n      // if enable is successful but doesn't return accounts, fall back to getAccount (not happy i have to do this...)\r\n      account = await window.BinanceChain.enable().then(sendReturn => sendReturn && parseSendReturn(sendReturn)[0])\r\n    }\r\n\r\n    return { provider: window.BinanceChain, ...(account ? { account } : {}) }\r\n  }\r\n\r\n  public async getProvider(): Promise<any> {\r\n    return window.BinanceChain\r\n  }\r\n\r\n  public async getChainId(): Promise<number | string> {\r\n    if (!window.BinanceChain) {\r\n      throw new NoEthereumProviderError()\r\n    }\r\n\r\n    let chainId\r\n    try {\r\n      chainId = await (window.BinanceChain.send as Send)('eth_chainId').then(parseSendReturn)\r\n    } catch {\r\n      warning(false, 'eth_chainId was unsuccessful, falling back to net_version')\r\n    }\r\n\r\n    if (!chainId) {\r\n      try {\r\n        chainId = await (window.BinanceChain.send as Send)('net_version').then(parseSendReturn)\r\n      } catch {\r\n        warning(false, 'net_version was unsuccessful, falling back to net version v2')\r\n      }\r\n    }\r\n\r\n    if (!chainId) {\r\n      try {\r\n        chainId = parseSendReturn((window.BinanceChain.send as SendOld)({ method: 'net_version' }))\r\n      } catch {\r\n        warning(false, 'net_version v2 was unsuccessful, falling back to manual matches and static properties')\r\n      }\r\n    }\r\n\r\n    if (!chainId) {\r\n      if ((window.BinanceChain as any).isDapper) {\r\n        chainId = parseSendReturn((window.BinanceChain as any).cachedResults.net_version)\r\n      } else {\r\n        chainId =\r\n          (window.BinanceChain as any).chainId ||\r\n          (window.BinanceChain as any).netVersion ||\r\n          (window.BinanceChain as any).networkVersion ||\r\n          (window.BinanceChain as any)._chainId\r\n      }\r\n    }\r\n\r\n    return chainId\r\n  }\r\n\r\n  public async getAccount(): Promise<null | string> {\r\n    if (!window.BinanceChain) {\r\n      throw new NoEthereumProviderError()\r\n    }\r\n\r\n    let account\r\n    try {\r\n      account = await (window.BinanceChain.send as Send)('eth_accounts').then(sendReturn => parseSendReturn(sendReturn)[0])\r\n    } catch {\r\n      warning(false, 'eth_accounts was unsuccessful, falling back to enable')\r\n    }\r\n\r\n    if (!account) {\r\n      try {\r\n        account = await window.BinanceChain.enable().then(sendReturn => parseSendReturn(sendReturn)[0])\r\n      } catch {\r\n        warning(false, 'enable was unsuccessful, falling back to eth_accounts v2')\r\n      }\r\n    }\r\n\r\n    if (!account) {\r\n      account = parseSendReturn((window.BinanceChain.send as SendOld)({ method: 'eth_accounts' }))[0]\r\n    }\r\n\r\n    return account\r\n  }\r\n\r\n  public deactivate() {\r\n    if (window.BinanceChain && window.BinanceChain.removeListener) {\r\n      window.BinanceChain.removeListener('chainChanged', this.handleChainChanged)\r\n      window.BinanceChain.removeListener('accountsChanged', this.handleAccountsChanged)\r\n      window.BinanceChain.removeListener('close', this.handleClose)\r\n      window.BinanceChain.removeListener('networkChanged', this.handleNetworkChanged)\r\n    }\r\n  }\r\n\r\n  public async isAuthorized(): Promise<boolean> {\r\n    if (!window.BinanceChain) {\r\n      return false\r\n    }\r\n\r\n    try {\r\n      return await (window.BinanceChain.send as Send)('eth_accounts').then(sendReturn => {\r\n        if (parseSendReturn(sendReturn).length > 0) {\r\n          return true\r\n        } else {\r\n          return false\r\n        }\r\n      })\r\n    } catch {\r\n      return false\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}