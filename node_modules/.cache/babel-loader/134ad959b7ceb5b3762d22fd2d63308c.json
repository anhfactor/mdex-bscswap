{"ast":null,"code":"import{MaxUint256}from'@ethersproject/constants';import{ETHER,Token,TradeType}from'@bscswap/sdk';import{getTradeVersion}from'../data/V1';import{Version}from'../hooks/useToggledVersion';function toHex(currencyAmount){return\"0x\".concat(currencyAmount.raw.toString(16));}function deadlineFromNow(ttl){return\"0x\".concat((Math.floor(new Date().getTime()/1000)+ttl).toString(16));}/**\n * Get the arguments to make for a swap\n * @param trade trade to get v1 arguments for swapping\n * @param options options for swapping\n */export default function v1SwapArguments(trade,options){if(getTradeVersion(trade)!==Version.v1){throw new Error('invalid trade version');}if(trade.route.pairs.length>2){throw new Error('too many pairs');}var isExactIn=trade.tradeType===TradeType.EXACT_INPUT;var inputETH=trade.inputAmount.currency===ETHER;var outputETH=trade.outputAmount.currency===ETHER;if(inputETH&&outputETH)throw new Error('ETHER to ETHER');var minimumAmountOut=toHex(trade.minimumAmountOut(options.allowedSlippage));var maximumAmountIn=toHex(trade.maximumAmountIn(options.allowedSlippage));var deadline=deadlineFromNow(options.ttl);if(isExactIn){if(inputETH){return{methodName:'ethToTokenTransferInput',args:[minimumAmountOut,deadline,options.recipient],value:maximumAmountIn};}else if(outputETH){return{methodName:'tokenToEthTransferInput',args:[maximumAmountIn,minimumAmountOut,deadline,options.recipient],value:'0x0'};}else{var outputToken=trade.outputAmount.currency;// should never happen, needed for type check\nif(!(outputToken instanceof Token)){throw new Error('token to token');}return{methodName:'tokenToTokenTransferInput',args:[maximumAmountIn,minimumAmountOut,'0x1',deadline,options.recipient,outputToken.address],value:'0x0'};}}else{if(inputETH){return{methodName:'ethToTokenTransferOutput',args:[minimumAmountOut,deadline,options.recipient],value:maximumAmountIn};}else if(outputETH){return{methodName:'tokenToEthTransferOutput',args:[minimumAmountOut,maximumAmountIn,deadline,options.recipient],value:'0x0'};}else{var output=trade.outputAmount.currency;if(!(output instanceof Token)){throw new Error('invalid output amount currency');}return{methodName:'tokenToTokenTransferOutput',args:[minimumAmountOut,maximumAmountIn,MaxUint256.toHexString(),deadline,options.recipient,output.address],value:'0x0'};}}}","map":{"version":3,"sources":["/Users/lap14205/Documents/home/blockchain_learning/mdex-bscswap/src/utils/v1SwapArguments.ts"],"names":["MaxUint256","ETHER","Token","TradeType","getTradeVersion","Version","toHex","currencyAmount","raw","toString","deadlineFromNow","ttl","Math","floor","Date","getTime","v1SwapArguments","trade","options","v1","Error","route","pairs","length","isExactIn","tradeType","EXACT_INPUT","inputETH","inputAmount","currency","outputETH","outputAmount","minimumAmountOut","allowedSlippage","maximumAmountIn","deadline","methodName","args","recipient","value","outputToken","address","output","toHexString"],"mappings":"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","sourcesContent":["import { MaxUint256 } from '@ethersproject/constants'\nimport { CurrencyAmount, ETHER, SwapParameters, Token, Trade, TradeOptions, TradeType } from '@bscswap/sdk'\nimport { getTradeVersion } from '../data/V1'\nimport { Version } from '../hooks/useToggledVersion'\n\nfunction toHex(currencyAmount: CurrencyAmount): string {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\nfunction deadlineFromNow(ttl: number): string {\n  return `0x${(Math.floor(new Date().getTime() / 1000) + ttl).toString(16)}`\n}\n\n/**\n * Get the arguments to make for a swap\n * @param trade trade to get v1 arguments for swapping\n * @param options options for swapping\n */\nexport default function v1SwapArguments(trade: Trade, options: Omit<TradeOptions, 'feeOnTransfer'>): SwapParameters {\n  if (getTradeVersion(trade) !== Version.v1) {\n    throw new Error('invalid trade version')\n  }\n  if (trade.route.pairs.length > 2) {\n    throw new Error('too many pairs')\n  }\n  const isExactIn = trade.tradeType === TradeType.EXACT_INPUT\n  const inputETH = trade.inputAmount.currency === ETHER\n  const outputETH = trade.outputAmount.currency === ETHER\n  if (inputETH && outputETH) throw new Error('ETHER to ETHER')\n  const minimumAmountOut = toHex(trade.minimumAmountOut(options.allowedSlippage))\n  const maximumAmountIn = toHex(trade.maximumAmountIn(options.allowedSlippage))\n  const deadline = deadlineFromNow(options.ttl)\n  if (isExactIn) {\n    if (inputETH) {\n      return {\n        methodName: 'ethToTokenTransferInput',\n        args: [minimumAmountOut, deadline, options.recipient],\n        value: maximumAmountIn\n      }\n    } else if (outputETH) {\n      return {\n        methodName: 'tokenToEthTransferInput',\n        args: [maximumAmountIn, minimumAmountOut, deadline, options.recipient],\n        value: '0x0'\n      }\n    } else {\n      const outputToken = trade.outputAmount.currency\n      // should never happen, needed for type check\n      if (!(outputToken instanceof Token)) {\n        throw new Error('token to token')\n      }\n      return {\n        methodName: 'tokenToTokenTransferInput',\n        args: [maximumAmountIn, minimumAmountOut, '0x1', deadline, options.recipient, outputToken.address],\n        value: '0x0'\n      }\n    }\n  } else {\n    if (inputETH) {\n      return {\n        methodName: 'ethToTokenTransferOutput',\n        args: [minimumAmountOut, deadline, options.recipient],\n        value: maximumAmountIn\n      }\n    } else if (outputETH) {\n      return {\n        methodName: 'tokenToEthTransferOutput',\n        args: [minimumAmountOut, maximumAmountIn, deadline, options.recipient],\n        value: '0x0'\n      }\n    } else {\n      const output = trade.outputAmount.currency\n      if (!(output instanceof Token)) {\n        throw new Error('invalid output amount currency')\n      }\n\n      return {\n        methodName: 'tokenToTokenTransferOutput',\n        args: [\n          minimumAmountOut,\n          maximumAmountIn,\n          MaxUint256.toHexString(),\n          deadline,\n          options.recipient,\n          output.address\n        ],\n        value: '0x0'\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}