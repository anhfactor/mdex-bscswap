{"ast":null,"code":"import _toConsumableArray from\"/Users/lap14205/Documents/home/blockchain_learning/bscswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/Users/lap14205/Documents/home/blockchain_learning/bscswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{Trade}from'@bscswap/sdk';import flatMap from'lodash.flatmap';import{useMemo}from'react';import{BASES_TO_CHECK_TRADES_AGAINST,CUSTOM_BASES}from'../constants';import{PairState,usePairs}from'../data/Reserves';import{wrappedCurrency}from'../utils/wrappedCurrency';import{useActiveWeb3React}from'./index';function useAllCommonPairs(currencyA,currencyB){var _useActiveWeb3React=useActiveWeb3React(),chainId=_useActiveWeb3React.chainId;var bases=chainId?BASES_TO_CHECK_TRADES_AGAINST[chainId]:[];var _ref=chainId?[wrappedCurrency(currencyA,chainId),wrappedCurrency(currencyB,chainId)]:[undefined,undefined],_ref2=_slicedToArray(_ref,2),tokenA=_ref2[0],tokenB=_ref2[1];var allPairCombinations=useMemo(function(){return[// the direct pair\n[tokenA,tokenB]].concat(_toConsumableArray(bases.map(function(base){return[tokenA,base];})),_toConsumableArray(bases.map(function(base){return[tokenB,base];})),_toConsumableArray(flatMap(bases,function(base){return bases.map(function(otherBase){return[base,otherBase];});}))).filter(function(tokens){return Boolean(tokens[0]&&tokens[1]);}).filter(function(_ref3){var _ref4=_slicedToArray(_ref3,2),tokenA=_ref4[0],tokenB=_ref4[1];if(!chainId)return true;var customBases=CUSTOM_BASES[chainId];if(!customBases)return true;var customBasesA=customBases[tokenA.address];var customBasesB=customBases[tokenB.address];if(!customBasesA&&!customBasesB)return true;if(customBasesA&&customBasesA.findIndex(function(base){return tokenB.equals(base);})===-1)return false;if(customBasesB&&customBasesB.findIndex(function(base){return tokenA.equals(base);})===-1)return false;return true;});},[tokenA,tokenB,bases,chainId]);var allPairs=usePairs(allPairCombinations);// only pass along valid pairs, non-duplicated pairs\nreturn useMemo(function(){return Object.values(allPairs// filter out invalid pairs\n.filter(function(result){return Boolean(result[0]===PairState.EXISTS&&result[1]);})// filter out duplicated pairs\n.reduce(function(memo,_ref5){var _memo$curr$liquidityT;var _ref6=_slicedToArray(_ref5,2),curr=_ref6[1];memo[curr.liquidityToken.address]=(_memo$curr$liquidityT=memo[curr.liquidityToken.address])!==null&&_memo$curr$liquidityT!==void 0?_memo$curr$liquidityT:curr;return memo;},{}));},[allPairs]);}/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */export function useTradeExactIn(currencyAmountIn,currencyOut){var allowedPairs=useAllCommonPairs(currencyAmountIn===null||currencyAmountIn===void 0?void 0:currencyAmountIn.currency,currencyOut);return useMemo(function(){if(currencyAmountIn&&currencyOut&&allowedPairs.length>0){var _Trade$bestTradeExact;return(_Trade$bestTradeExact=Trade.bestTradeExactIn(allowedPairs,currencyAmountIn,currencyOut,{maxHops:3,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact!==void 0?_Trade$bestTradeExact:null;}return null;},[allowedPairs,currencyAmountIn,currencyOut]);}/**\n * Returns the best trade for the token in to the exact amount of token out\n */export function useTradeExactOut(currencyIn,currencyAmountOut){var allowedPairs=useAllCommonPairs(currencyIn,currencyAmountOut===null||currencyAmountOut===void 0?void 0:currencyAmountOut.currency);return useMemo(function(){if(currencyIn&&currencyAmountOut&&allowedPairs.length>0){var _Trade$bestTradeExact2;return(_Trade$bestTradeExact2=Trade.bestTradeExactOut(allowedPairs,currencyIn,currencyAmountOut,{maxHops:3,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact2!==void 0?_Trade$bestTradeExact2:null;}return null;},[allowedPairs,currencyIn,currencyAmountOut]);}","map":{"version":3,"sources":["/Users/lap14205/Documents/home/blockchain_learning/bscswap-interface/src/hooks/Trades.ts"],"names":["Trade","flatMap","useMemo","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","PairState","usePairs","wrappedCurrency","useActiveWeb3React","useAllCommonPairs","currencyA","currencyB","chainId","bases","undefined","tokenA","tokenB","allPairCombinations","map","base","otherBase","filter","tokens","Boolean","customBases","customBasesA","address","customBasesB","findIndex","equals","allPairs","Object","values","result","EXISTS","reduce","memo","curr","liquidityToken","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","length","bestTradeExactIn","maxHops","maxNumResults","useTradeExactOut","currencyIn","currencyAmountOut","bestTradeExactOut"],"mappings":"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","sourcesContent":["import { Currency, CurrencyAmount, Pair, Token, Trade } from '@bscswap/sdk'\nimport flatMap from 'lodash.flatmap'\nimport { useMemo } from 'react'\n\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants'\nimport { PairState, usePairs } from '../data/Reserves'\nimport { wrappedCurrency } from '../utils/wrappedCurrency'\n\nimport { useActiveWeb3React } from './index'\n\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n  const { chainId } = useActiveWeb3React()\n\n  const bases: Token[] = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []\n\n  const [tokenA, tokenB] = chainId\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n    : [undefined, undefined]\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      [\n        // the direct pair\n        [tokenA, tokenB],\n        // token A against all bases\n        ...bases.map((base): [Token | undefined, Token | undefined] => [tokenA, base]),\n        // token B against all bases\n        ...bases.map((base): [Token | undefined, Token | undefined] => [tokenB, base]),\n        // each base against all bases\n        ...flatMap(bases, (base): [Token, Token][] => bases.map(otherBase => [base, otherBase]))\n      ]\n        .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n        .filter(([tokenA, tokenB]) => {\n          if (!chainId) return true\n          const customBases = CUSTOM_BASES[chainId]\n          if (!customBases) return true\n\n          const customBasesA: Token[] | undefined = customBases[tokenA.address]\n          const customBasesB: Token[] | undefined = customBases[tokenB.address]\n\n          if (!customBasesA && !customBasesB) return true\n\n          if (customBasesA && customBasesA.findIndex(base => tokenB.equals(base)) === -1) return false\n          if (customBasesB && customBasesB.findIndex(base => tokenA.equals(base)) === -1) return false\n\n          return true\n        }),\n    [tokenA, tokenB, bases, chainId]\n  )\n\n  const allPairs = usePairs(allPairCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {})\n      ),\n    [allPairs]\n  )\n}\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useTradeExactIn(currencyAmountIn?: CurrencyAmount, currencyOut?: Currency): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      return (\n        Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 3, maxNumResults: 1 })[0] ?? null\n      )\n    }\n    return null\n  }, [allowedPairs, currencyAmountIn, currencyOut])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useTradeExactOut(currencyIn?: Currency, currencyAmountOut?: CurrencyAmount): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      return (\n        Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 3, maxNumResults: 1 })[0] ??\n        null\n      )\n    }\n    return null\n  }, [allowedPairs, currencyIn, currencyAmountOut])\n}\n"]},"metadata":{},"sourceType":"module"}