{"ast":null,"code":"import { INITIAL_ALLOWED_SLIPPAGE, DEFAULT_DEADLINE_FROM_NOW } from '../../constants';\nimport { createReducer } from '@reduxjs/toolkit';\nimport { addSerializedPair, addSerializedToken, dismissTokenWarning, removeSerializedPair, removeSerializedToken, updateMatchesDarkMode, updateUserDarkMode, updateVersion, updateUserExpertMode, updateUserSlippageTolerance, updateUserDeadline } from './actions';\n\nconst currentTimestamp = () => new Date().getTime();\n\nfunction pairKey(token0Address, token1Address) {\n  return `${token0Address};${token1Address}`;\n}\n\nexport const initialState = {\n  userDarkMode: null,\n  matchesDarkMode: false,\n  userExpertMode: false,\n  userSlippageTolerance: INITIAL_ALLOWED_SLIPPAGE,\n  userDeadline: DEFAULT_DEADLINE_FROM_NOW,\n  tokens: {},\n  pairs: {},\n  timestamp: currentTimestamp()\n};\nexport default createReducer(initialState, builder => builder.addCase(updateVersion, state => {\n  // slippage isnt being tracked in local storage, reset to default\n  if (typeof state.userSlippageTolerance !== 'number') {\n    state.userSlippageTolerance = INITIAL_ALLOWED_SLIPPAGE;\n  } // deadline isnt being tracked in local storage, reset to default\n\n\n  if (typeof state.userDeadline !== 'number') {\n    state.userDeadline = DEFAULT_DEADLINE_FROM_NOW;\n  }\n\n  state.lastUpdateVersionTimestamp = currentTimestamp();\n}).addCase(updateUserDarkMode, (state, action) => {\n  state.userDarkMode = action.payload.userDarkMode;\n  state.timestamp = currentTimestamp();\n}).addCase(updateMatchesDarkMode, (state, action) => {\n  state.matchesDarkMode = action.payload.matchesDarkMode;\n  state.timestamp = currentTimestamp();\n}).addCase(updateUserExpertMode, (state, action) => {\n  state.userExpertMode = action.payload.userExpertMode;\n  state.timestamp = currentTimestamp();\n}).addCase(updateUserSlippageTolerance, (state, action) => {\n  state.userSlippageTolerance = action.payload.userSlippageTolerance;\n  state.timestamp = currentTimestamp();\n}).addCase(updateUserDeadline, (state, action) => {\n  state.userDeadline = action.payload.userDeadline;\n  state.timestamp = currentTimestamp();\n}).addCase(addSerializedToken, (state, {\n  payload: {\n    serializedToken\n  }\n}) => {\n  state.tokens[serializedToken.chainId] = state.tokens[serializedToken.chainId] || {};\n  state.tokens[serializedToken.chainId][serializedToken.address] = serializedToken;\n  state.timestamp = currentTimestamp();\n}).addCase(removeSerializedToken, (state, {\n  payload: {\n    address,\n    chainId\n  }\n}) => {\n  state.tokens[chainId] = state.tokens[chainId] || {};\n  delete state.tokens[chainId][address];\n  state.timestamp = currentTimestamp();\n}).addCase(dismissTokenWarning, (state, {\n  payload: {\n    chainId,\n    tokenAddress\n  }\n}) => {\n  var _state$dismissedToken, _state$dismissedToken2;\n\n  state.dismissedTokenWarnings = (_state$dismissedToken = state.dismissedTokenWarnings) !== null && _state$dismissedToken !== void 0 ? _state$dismissedToken : {};\n  state.dismissedTokenWarnings[chainId] = (_state$dismissedToken2 = state.dismissedTokenWarnings[chainId]) !== null && _state$dismissedToken2 !== void 0 ? _state$dismissedToken2 : {};\n  state.dismissedTokenWarnings[chainId][tokenAddress] = true;\n}).addCase(addSerializedPair, (state, {\n  payload: {\n    serializedPair\n  }\n}) => {\n  if (serializedPair.token0.chainId === serializedPair.token1.chainId && serializedPair.token0.address !== serializedPair.token1.address) {\n    const chainId = serializedPair.token0.chainId;\n    state.pairs[chainId] = state.pairs[chainId] || {};\n    state.pairs[chainId][pairKey(serializedPair.token0.address, serializedPair.token1.address)] = serializedPair;\n  }\n\n  state.timestamp = currentTimestamp();\n}).addCase(removeSerializedPair, (state, {\n  payload: {\n    chainId,\n    tokenAAddress,\n    tokenBAddress\n  }\n}) => {\n  if (state.pairs[chainId]) {\n    // just delete both keys if either exists\n    delete state.pairs[chainId][pairKey(tokenAAddress, tokenBAddress)];\n    delete state.pairs[chainId][pairKey(tokenBAddress, tokenAAddress)];\n  }\n\n  state.timestamp = currentTimestamp();\n}));","map":{"version":3,"sources":["/Users/lap14205/Documents/home/blockchain_learning/mdex-bscswap/src/state/user/reducer.ts"],"names":["INITIAL_ALLOWED_SLIPPAGE","DEFAULT_DEADLINE_FROM_NOW","createReducer","addSerializedPair","addSerializedToken","dismissTokenWarning","removeSerializedPair","removeSerializedToken","updateMatchesDarkMode","updateUserDarkMode","updateVersion","updateUserExpertMode","updateUserSlippageTolerance","updateUserDeadline","currentTimestamp","Date","getTime","pairKey","token0Address","token1Address","initialState","userDarkMode","matchesDarkMode","userExpertMode","userSlippageTolerance","userDeadline","tokens","pairs","timestamp","builder","addCase","state","lastUpdateVersionTimestamp","action","payload","serializedToken","chainId","address","tokenAddress","dismissedTokenWarnings","serializedPair","token0","token1","tokenAAddress","tokenBAddress"],"mappings":"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","sourcesContent":["import { INITIAL_ALLOWED_SLIPPAGE, DEFAULT_DEADLINE_FROM_NOW } from '../../constants'\nimport { createReducer } from '@reduxjs/toolkit'\nimport {\n  addSerializedPair,\n  addSerializedToken,\n  dismissTokenWarning,\n  removeSerializedPair,\n  removeSerializedToken,\n  SerializedPair,\n  SerializedToken,\n  updateMatchesDarkMode,\n  updateUserDarkMode,\n  updateVersion,\n  updateUserExpertMode,\n  updateUserSlippageTolerance,\n  updateUserDeadline\n} from './actions'\n\nconst currentTimestamp = () => new Date().getTime()\n\nexport interface UserState {\n  // the timestamp of the last updateVersion action\n  lastUpdateVersionTimestamp?: number\n\n  userDarkMode: boolean | null // the user's choice for dark mode or light mode\n  matchesDarkMode: boolean // whether the dark mode media query matches\n\n  userExpertMode: boolean\n\n  // user defined slippage tolerance in bips, used in all txns\n  userSlippageTolerance: number\n\n  // deadline set by user in minutes, used in all txns\n  userDeadline: number\n\n  tokens: {\n    [chainId: number]: {\n      [address: string]: SerializedToken\n    }\n  }\n\n  // the token warnings that the user has dismissed\n  dismissedTokenWarnings?: {\n    [chainId: number]: {\n      [tokenAddress: string]: true\n    }\n  }\n\n  pairs: {\n    [chainId: number]: {\n      // keyed by token0Address:token1Address\n      [key: string]: SerializedPair\n    }\n  }\n\n  timestamp: number\n}\n\nfunction pairKey(token0Address: string, token1Address: string) {\n  return `${token0Address};${token1Address}`\n}\n\nexport const initialState: UserState = {\n  userDarkMode: null,\n  matchesDarkMode: false,\n  userExpertMode: false,\n  userSlippageTolerance: INITIAL_ALLOWED_SLIPPAGE,\n  userDeadline: DEFAULT_DEADLINE_FROM_NOW,\n  tokens: {},\n  pairs: {},\n  timestamp: currentTimestamp()\n}\n\nexport default createReducer(initialState, builder =>\n  builder\n    .addCase(updateVersion, state => {\n      // slippage isnt being tracked in local storage, reset to default\n      if (typeof state.userSlippageTolerance !== 'number') {\n        state.userSlippageTolerance = INITIAL_ALLOWED_SLIPPAGE\n      }\n\n      // deadline isnt being tracked in local storage, reset to default\n      if (typeof state.userDeadline !== 'number') {\n        state.userDeadline = DEFAULT_DEADLINE_FROM_NOW\n      }\n\n      state.lastUpdateVersionTimestamp = currentTimestamp()\n    })\n    .addCase(updateUserDarkMode, (state, action) => {\n      state.userDarkMode = action.payload.userDarkMode\n      state.timestamp = currentTimestamp()\n    })\n    .addCase(updateMatchesDarkMode, (state, action) => {\n      state.matchesDarkMode = action.payload.matchesDarkMode\n      state.timestamp = currentTimestamp()\n    })\n    .addCase(updateUserExpertMode, (state, action) => {\n      state.userExpertMode = action.payload.userExpertMode\n      state.timestamp = currentTimestamp()\n    })\n    .addCase(updateUserSlippageTolerance, (state, action) => {\n      state.userSlippageTolerance = action.payload.userSlippageTolerance\n      state.timestamp = currentTimestamp()\n    })\n    .addCase(updateUserDeadline, (state, action) => {\n      state.userDeadline = action.payload.userDeadline\n      state.timestamp = currentTimestamp()\n    })\n    .addCase(addSerializedToken, (state, { payload: { serializedToken } }) => {\n      state.tokens[serializedToken.chainId] = state.tokens[serializedToken.chainId] || {}\n      state.tokens[serializedToken.chainId][serializedToken.address] = serializedToken\n      state.timestamp = currentTimestamp()\n    })\n    .addCase(removeSerializedToken, (state, { payload: { address, chainId } }) => {\n      state.tokens[chainId] = state.tokens[chainId] || {}\n      delete state.tokens[chainId][address]\n      state.timestamp = currentTimestamp()\n    })\n    .addCase(dismissTokenWarning, (state, { payload: { chainId, tokenAddress } }) => {\n      state.dismissedTokenWarnings = state.dismissedTokenWarnings ?? {}\n      state.dismissedTokenWarnings[chainId] = state.dismissedTokenWarnings[chainId] ?? {}\n      state.dismissedTokenWarnings[chainId][tokenAddress] = true\n    })\n    .addCase(addSerializedPair, (state, { payload: { serializedPair } }) => {\n      if (\n        serializedPair.token0.chainId === serializedPair.token1.chainId &&\n        serializedPair.token0.address !== serializedPair.token1.address\n      ) {\n        const chainId = serializedPair.token0.chainId\n        state.pairs[chainId] = state.pairs[chainId] || {}\n        state.pairs[chainId][pairKey(serializedPair.token0.address, serializedPair.token1.address)] = serializedPair\n      }\n      state.timestamp = currentTimestamp()\n    })\n    .addCase(removeSerializedPair, (state, { payload: { chainId, tokenAAddress, tokenBAddress } }) => {\n      if (state.pairs[chainId]) {\n        // just delete both keys if either exists\n        delete state.pairs[chainId][pairKey(tokenAAddress, tokenBAddress)]\n        delete state.pairs[chainId][pairKey(tokenBAddress, tokenAAddress)]\n      }\n      state.timestamp = currentTimestamp()\n    })\n)\n"]},"metadata":{},"sourceType":"module"}