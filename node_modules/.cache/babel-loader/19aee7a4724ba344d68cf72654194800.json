{"ast":null,"code":"import { MaxUint256 } from '@ethersproject/constants';\nimport { ETHER, Token, TradeType } from '@bscswap/sdk';\nimport { getTradeVersion } from '../data/V1';\nimport { Version } from '../hooks/useToggledVersion';\n\nfunction toHex(currencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`;\n}\n\nfunction deadlineFromNow(ttl) {\n  return `0x${(Math.floor(new Date().getTime() / 1000) + ttl).toString(16)}`;\n}\n/**\n * Get the arguments to make for a swap\n * @param trade trade to get v1 arguments for swapping\n * @param options options for swapping\n */\n\n\nexport default function v1SwapArguments(trade, options) {\n  if (getTradeVersion(trade) !== Version.v1) {\n    throw new Error('invalid trade version');\n  }\n\n  if (trade.route.pairs.length > 2) {\n    throw new Error('too many pairs');\n  }\n\n  const isExactIn = trade.tradeType === TradeType.EXACT_INPUT;\n  const inputETH = trade.inputAmount.currency === ETHER;\n  const outputETH = trade.outputAmount.currency === ETHER;\n  if (inputETH && outputETH) throw new Error('ETHER to ETHER');\n  const minimumAmountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));\n  const maximumAmountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));\n  const deadline = deadlineFromNow(options.ttl);\n\n  if (isExactIn) {\n    if (inputETH) {\n      return {\n        methodName: 'ethToTokenTransferInput',\n        args: [minimumAmountOut, deadline, options.recipient],\n        value: maximumAmountIn\n      };\n    } else if (outputETH) {\n      return {\n        methodName: 'tokenToEthTransferInput',\n        args: [maximumAmountIn, minimumAmountOut, deadline, options.recipient],\n        value: '0x0'\n      };\n    } else {\n      const outputToken = trade.outputAmount.currency; // should never happen, needed for type check\n\n      if (!(outputToken instanceof Token)) {\n        throw new Error('token to token');\n      }\n\n      return {\n        methodName: 'tokenToTokenTransferInput',\n        args: [maximumAmountIn, minimumAmountOut, '0x1', deadline, options.recipient, outputToken.address],\n        value: '0x0'\n      };\n    }\n  } else {\n    if (inputETH) {\n      return {\n        methodName: 'ethToTokenTransferOutput',\n        args: [minimumAmountOut, deadline, options.recipient],\n        value: maximumAmountIn\n      };\n    } else if (outputETH) {\n      return {\n        methodName: 'tokenToEthTransferOutput',\n        args: [minimumAmountOut, maximumAmountIn, deadline, options.recipient],\n        value: '0x0'\n      };\n    } else {\n      const output = trade.outputAmount.currency;\n\n      if (!(output instanceof Token)) {\n        throw new Error('invalid output amount currency');\n      }\n\n      return {\n        methodName: 'tokenToTokenTransferOutput',\n        args: [minimumAmountOut, maximumAmountIn, MaxUint256.toHexString(), deadline, options.recipient, output.address],\n        value: '0x0'\n      };\n    }\n  }\n}","map":{"version":3,"sources":["/Users/lap14205/Documents/home/blockchain_learning/mdex-bscswap/src/utils/v1SwapArguments.ts"],"names":["MaxUint256","ETHER","Token","TradeType","getTradeVersion","Version","toHex","currencyAmount","raw","toString","deadlineFromNow","ttl","Math","floor","Date","getTime","v1SwapArguments","trade","options","v1","Error","route","pairs","length","isExactIn","tradeType","EXACT_INPUT","inputETH","inputAmount","currency","outputETH","outputAmount","minimumAmountOut","allowedSlippage","maximumAmountIn","deadline","methodName","args","recipient","value","outputToken","address","output","toHexString"],"mappings":"AAAA,SAASA,UAAT,QAA2B,0BAA3B;AACA,SAAyBC,KAAzB,EAAgDC,KAAhD,EAA4EC,SAA5E,QAA6F,cAA7F;AACA,SAASC,eAAT,QAAgC,YAAhC;AACA,SAASC,OAAT,QAAwB,4BAAxB;;AAEA,SAASC,KAAT,CAAeC,cAAf,EAAuD;AACrD,SAAQ,KAAIA,cAAc,CAACC,GAAf,CAAmBC,QAAnB,CAA4B,EAA5B,CAAgC,EAA5C;AACD;;AAED,SAASC,eAAT,CAAyBC,GAAzB,EAA8C;AAC5C,SAAQ,KAAI,CAACC,IAAI,CAACC,KAAL,CAAW,IAAIC,IAAJ,GAAWC,OAAX,KAAuB,IAAlC,IAA0CJ,GAA3C,EAAgDF,QAAhD,CAAyD,EAAzD,CAA6D,EAAzE;AACD;AAED;;;;;;;AAKA,eAAe,SAASO,eAAT,CAAyBC,KAAzB,EAAuCC,OAAvC,EAAqG;AAClH,MAAId,eAAe,CAACa,KAAD,CAAf,KAA2BZ,OAAO,CAACc,EAAvC,EAA2C;AACzC,UAAM,IAAIC,KAAJ,CAAU,uBAAV,CAAN;AACD;;AACD,MAAIH,KAAK,CAACI,KAAN,CAAYC,KAAZ,CAAkBC,MAAlB,GAA2B,CAA/B,EAAkC;AAChC,UAAM,IAAIH,KAAJ,CAAU,gBAAV,CAAN;AACD;;AACD,QAAMI,SAAS,GAAGP,KAAK,CAACQ,SAAN,KAAoBtB,SAAS,CAACuB,WAAhD;AACA,QAAMC,QAAQ,GAAGV,KAAK,CAACW,WAAN,CAAkBC,QAAlB,KAA+B5B,KAAhD;AACA,QAAM6B,SAAS,GAAGb,KAAK,CAACc,YAAN,CAAmBF,QAAnB,KAAgC5B,KAAlD;AACA,MAAI0B,QAAQ,IAAIG,SAAhB,EAA2B,MAAM,IAAIV,KAAJ,CAAU,gBAAV,CAAN;AAC3B,QAAMY,gBAAgB,GAAG1B,KAAK,CAACW,KAAK,CAACe,gBAAN,CAAuBd,OAAO,CAACe,eAA/B,CAAD,CAA9B;AACA,QAAMC,eAAe,GAAG5B,KAAK,CAACW,KAAK,CAACiB,eAAN,CAAsBhB,OAAO,CAACe,eAA9B,CAAD,CAA7B;AACA,QAAME,QAAQ,GAAGzB,eAAe,CAACQ,OAAO,CAACP,GAAT,CAAhC;;AACA,MAAIa,SAAJ,EAAe;AACb,QAAIG,QAAJ,EAAc;AACZ,aAAO;AACLS,QAAAA,UAAU,EAAE,yBADP;AAELC,QAAAA,IAAI,EAAE,CAACL,gBAAD,EAAmBG,QAAnB,EAA6BjB,OAAO,CAACoB,SAArC,CAFD;AAGLC,QAAAA,KAAK,EAAEL;AAHF,OAAP;AAKD,KAND,MAMO,IAAIJ,SAAJ,EAAe;AACpB,aAAO;AACLM,QAAAA,UAAU,EAAE,yBADP;AAELC,QAAAA,IAAI,EAAE,CAACH,eAAD,EAAkBF,gBAAlB,EAAoCG,QAApC,EAA8CjB,OAAO,CAACoB,SAAtD,CAFD;AAGLC,QAAAA,KAAK,EAAE;AAHF,OAAP;AAKD,KANM,MAMA;AACL,YAAMC,WAAW,GAAGvB,KAAK,CAACc,YAAN,CAAmBF,QAAvC,CADK,CAEL;;AACA,UAAI,EAAEW,WAAW,YAAYtC,KAAzB,CAAJ,EAAqC;AACnC,cAAM,IAAIkB,KAAJ,CAAU,gBAAV,CAAN;AACD;;AACD,aAAO;AACLgB,QAAAA,UAAU,EAAE,2BADP;AAELC,QAAAA,IAAI,EAAE,CAACH,eAAD,EAAkBF,gBAAlB,EAAoC,KAApC,EAA2CG,QAA3C,EAAqDjB,OAAO,CAACoB,SAA7D,EAAwEE,WAAW,CAACC,OAApF,CAFD;AAGLF,QAAAA,KAAK,EAAE;AAHF,OAAP;AAKD;AACF,GAzBD,MAyBO;AACL,QAAIZ,QAAJ,EAAc;AACZ,aAAO;AACLS,QAAAA,UAAU,EAAE,0BADP;AAELC,QAAAA,IAAI,EAAE,CAACL,gBAAD,EAAmBG,QAAnB,EAA6BjB,OAAO,CAACoB,SAArC,CAFD;AAGLC,QAAAA,KAAK,EAAEL;AAHF,OAAP;AAKD,KAND,MAMO,IAAIJ,SAAJ,EAAe;AACpB,aAAO;AACLM,QAAAA,UAAU,EAAE,0BADP;AAELC,QAAAA,IAAI,EAAE,CAACL,gBAAD,EAAmBE,eAAnB,EAAoCC,QAApC,EAA8CjB,OAAO,CAACoB,SAAtD,CAFD;AAGLC,QAAAA,KAAK,EAAE;AAHF,OAAP;AAKD,KANM,MAMA;AACL,YAAMG,MAAM,GAAGzB,KAAK,CAACc,YAAN,CAAmBF,QAAlC;;AACA,UAAI,EAAEa,MAAM,YAAYxC,KAApB,CAAJ,EAAgC;AAC9B,cAAM,IAAIkB,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,aAAO;AACLgB,QAAAA,UAAU,EAAE,4BADP;AAELC,QAAAA,IAAI,EAAE,CACJL,gBADI,EAEJE,eAFI,EAGJlC,UAAU,CAAC2C,WAAX,EAHI,EAIJR,QAJI,EAKJjB,OAAO,CAACoB,SALJ,EAMJI,MAAM,CAACD,OANH,CAFD;AAULF,QAAAA,KAAK,EAAE;AAVF,OAAP;AAYD;AACF;AACF","sourcesContent":["import { MaxUint256 } from '@ethersproject/constants'\nimport { CurrencyAmount, ETHER, SwapParameters, Token, Trade, TradeOptions, TradeType } from '@bscswap/sdk'\nimport { getTradeVersion } from '../data/V1'\nimport { Version } from '../hooks/useToggledVersion'\n\nfunction toHex(currencyAmount: CurrencyAmount): string {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\nfunction deadlineFromNow(ttl: number): string {\n  return `0x${(Math.floor(new Date().getTime() / 1000) + ttl).toString(16)}`\n}\n\n/**\n * Get the arguments to make for a swap\n * @param trade trade to get v1 arguments for swapping\n * @param options options for swapping\n */\nexport default function v1SwapArguments(trade: Trade, options: Omit<TradeOptions, 'feeOnTransfer'>): SwapParameters {\n  if (getTradeVersion(trade) !== Version.v1) {\n    throw new Error('invalid trade version')\n  }\n  if (trade.route.pairs.length > 2) {\n    throw new Error('too many pairs')\n  }\n  const isExactIn = trade.tradeType === TradeType.EXACT_INPUT\n  const inputETH = trade.inputAmount.currency === ETHER\n  const outputETH = trade.outputAmount.currency === ETHER\n  if (inputETH && outputETH) throw new Error('ETHER to ETHER')\n  const minimumAmountOut = toHex(trade.minimumAmountOut(options.allowedSlippage))\n  const maximumAmountIn = toHex(trade.maximumAmountIn(options.allowedSlippage))\n  const deadline = deadlineFromNow(options.ttl)\n  if (isExactIn) {\n    if (inputETH) {\n      return {\n        methodName: 'ethToTokenTransferInput',\n        args: [minimumAmountOut, deadline, options.recipient],\n        value: maximumAmountIn\n      }\n    } else if (outputETH) {\n      return {\n        methodName: 'tokenToEthTransferInput',\n        args: [maximumAmountIn, minimumAmountOut, deadline, options.recipient],\n        value: '0x0'\n      }\n    } else {\n      const outputToken = trade.outputAmount.currency\n      // should never happen, needed for type check\n      if (!(outputToken instanceof Token)) {\n        throw new Error('token to token')\n      }\n      return {\n        methodName: 'tokenToTokenTransferInput',\n        args: [maximumAmountIn, minimumAmountOut, '0x1', deadline, options.recipient, outputToken.address],\n        value: '0x0'\n      }\n    }\n  } else {\n    if (inputETH) {\n      return {\n        methodName: 'ethToTokenTransferOutput',\n        args: [minimumAmountOut, deadline, options.recipient],\n        value: maximumAmountIn\n      }\n    } else if (outputETH) {\n      return {\n        methodName: 'tokenToEthTransferOutput',\n        args: [minimumAmountOut, maximumAmountIn, deadline, options.recipient],\n        value: '0x0'\n      }\n    } else {\n      const output = trade.outputAmount.currency\n      if (!(output instanceof Token)) {\n        throw new Error('invalid output amount currency')\n      }\n\n      return {\n        methodName: 'tokenToTokenTransferOutput',\n        args: [\n          minimumAmountOut,\n          maximumAmountIn,\n          MaxUint256.toHexString(),\n          deadline,\n          options.recipient,\n          output.address\n        ],\n        value: '0x0'\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}