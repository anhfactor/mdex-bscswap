{"ast":null,"code":"/**\n * Given a URI that may be ipfs, or http, or an ENS name, return the fetchable http(s) URLs for the same content\n * @param uri to convert to http url\n */\nexport default function uriToHttp(uri) {\n  try {\n    const parsed = new URL(uri);\n\n    if (parsed.protocol === 'http:') {\n      return ['https' + uri.substr(4), uri];\n    } else if (parsed.protocol === 'https:') {\n      return [uri];\n    } else if (parsed.protocol === 'ipfs:') {\n      var _parsed$href$match;\n\n      const hash = (_parsed$href$match = parsed.href.match(/^ipfs:(\\/\\/)?(.*)$/)) === null || _parsed$href$match === void 0 ? void 0 : _parsed$href$match[2];\n      return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`];\n    } else if (parsed.protocol === 'ipns:') {\n      var _parsed$href$match2;\n\n      const name = (_parsed$href$match2 = parsed.href.match(/^ipns:(\\/\\/)?(.*)$/)) === null || _parsed$href$match2 === void 0 ? void 0 : _parsed$href$match2[2];\n      return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`];\n    } else {\n      return [];\n    }\n  } catch (error) {\n    if (uri.toLowerCase().endsWith('.eth')) {\n      return [`https://${uri.toLowerCase()}.link`];\n    }\n\n    return [];\n  }\n}","map":{"version":3,"sources":["/Users/lap14205/Documents/home/blockchain_learning/mdex-bscswap/src/utils/uriToHttp.ts"],"names":["uriToHttp","uri","parsed","URL","protocol","substr","hash","href","match","name","error","toLowerCase","endsWith"],"mappings":"AAAA;;;;AAIA,eAAe,SAASA,SAAT,CAAmBC,GAAnB,EAA0C;AACvD,MAAI;AACF,UAAMC,MAAM,GAAG,IAAIC,GAAJ,CAAQF,GAAR,CAAf;;AACA,QAAIC,MAAM,CAACE,QAAP,KAAoB,OAAxB,EAAiC;AAC/B,aAAO,CAAC,UAAUH,GAAG,CAACI,MAAJ,CAAW,CAAX,CAAX,EAA0BJ,GAA1B,CAAP;AACD,KAFD,MAEO,IAAIC,MAAM,CAACE,QAAP,KAAoB,QAAxB,EAAkC;AACvC,aAAO,CAACH,GAAD,CAAP;AACD,KAFM,MAEA,IAAIC,MAAM,CAACE,QAAP,KAAoB,OAAxB,EAAiC;AAAA;;AACtC,YAAME,IAAI,yBAAGJ,MAAM,CAACK,IAAP,CAAYC,KAAZ,CAAkB,oBAAlB,CAAH,uDAAG,mBAA0C,CAA1C,CAAb;AACA,aAAO,CAAE,oCAAmCF,IAAK,GAA1C,EAA+C,wBAAuBA,IAAK,GAA3E,CAAP;AACD,KAHM,MAGA,IAAIJ,MAAM,CAACE,QAAP,KAAoB,OAAxB,EAAiC;AAAA;;AACtC,YAAMK,IAAI,0BAAGP,MAAM,CAACK,IAAP,CAAYC,KAAZ,CAAkB,oBAAlB,CAAH,wDAAG,oBAA0C,CAA1C,CAAb;AACA,aAAO,CAAE,oCAAmCC,IAAK,GAA1C,EAA+C,wBAAuBA,IAAK,GAA3E,CAAP;AACD,KAHM,MAGA;AACL,aAAO,EAAP;AACD;AACF,GAfD,CAeE,OAAOC,KAAP,EAAc;AACd,QAAIT,GAAG,CAACU,WAAJ,GAAkBC,QAAlB,CAA2B,MAA3B,CAAJ,EAAwC;AACtC,aAAO,CAAE,WAAUX,GAAG,CAACU,WAAJ,EAAkB,OAA9B,CAAP;AACD;;AACD,WAAO,EAAP;AACD;AACF","sourcesContent":["/**\n * Given a URI that may be ipfs, or http, or an ENS name, return the fetchable http(s) URLs for the same content\n * @param uri to convert to http url\n */\nexport default function uriToHttp(uri: string): string[] {\n  try {\n    const parsed = new URL(uri)\n    if (parsed.protocol === 'http:') {\n      return ['https' + uri.substr(4), uri]\n    } else if (parsed.protocol === 'https:') {\n      return [uri]\n    } else if (parsed.protocol === 'ipfs:') {\n      const hash = parsed.href.match(/^ipfs:(\\/\\/)?(.*)$/)?.[2]\n      return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`]\n    } else if (parsed.protocol === 'ipns:') {\n      const name = parsed.href.match(/^ipns:(\\/\\/)?(.*)$/)?.[2]\n      return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`]\n    } else {\n      return []\n    }\n  } catch (error) {\n    if (uri.toLowerCase().endsWith('.eth')) {\n      return [`https://${uri.toLowerCase()}.link`]\n    }\n    return []\n  }\n}\n"]},"metadata":{},"sourceType":"module"}