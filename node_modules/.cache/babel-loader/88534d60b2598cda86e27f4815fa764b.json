{"ast":null,"code":"import { Trade } from '@bscswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useMemo } from 'react';\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants';\nimport { PairState, usePairs } from '../data/Reserves';\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\nimport { useActiveWeb3React } from './index';\n\nfunction useAllCommonPairs(currencyA, currencyB) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const bases = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : [];\n  const [tokenA, tokenB] = chainId ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)] : [undefined, undefined];\n  const allPairCombinations = useMemo(() => [// the direct pair\n  [tokenA, tokenB], // token A against all bases\n  ...bases.map(base => [tokenA, base]), // token B against all bases\n  ...bases.map(base => [tokenB, base]), // each base against all bases\n  ...flatMap(bases, base => bases.map(otherBase => [base, otherBase]))].filter(tokens => Boolean(tokens[0] && tokens[1])).filter(([tokenA, tokenB]) => {\n    if (!chainId) return true;\n    const customBases = CUSTOM_BASES[chainId];\n    if (!customBases) return true;\n    const customBasesA = customBases[tokenA.address];\n    const customBasesB = customBases[tokenB.address];\n    if (!customBasesA && !customBasesB) return true;\n    if (customBasesA && customBasesA.findIndex(base => tokenB.equals(base)) === -1) return false;\n    if (customBasesB && customBasesB.findIndex(base => tokenA.equals(base)) === -1) return false;\n    return true;\n  }), [tokenA, tokenB, bases, chainId]);\n  const allPairs = usePairs(allPairCombinations); // only pass along valid pairs, non-duplicated pairs\n\n  return useMemo(() => Object.values(allPairs // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1])) // filter out duplicated pairs\n  .reduce((memo, [, curr]) => {\n    var _memo$curr$liquidityT;\n\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\n\n\nexport function useTradeExactIn(currencyAmountIn, currencyOut) {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      var _Trade$bestTradeExact;\n\n      return (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n        maxHops: 3,\n        maxNumResults: 1\n      })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n    }\n\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut]);\n}\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\n\nexport function useTradeExactOut(currencyIn, currencyAmountOut) {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      var _Trade$bestTradeExact2;\n\n      return (_Trade$bestTradeExact2 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n        maxHops: 3,\n        maxNumResults: 1\n      })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null;\n    }\n\n    return null;\n  }, [allowedPairs, currencyIn, currencyAmountOut]);\n}","map":{"version":3,"sources":["/Users/lap14205/Documents/home/blockchain_learning/mdex-bscswap/src/hooks/Trades.ts"],"names":["Trade","flatMap","useMemo","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","PairState","usePairs","wrappedCurrency","useActiveWeb3React","useAllCommonPairs","currencyA","currencyB","chainId","bases","tokenA","tokenB","undefined","allPairCombinations","map","base","otherBase","filter","tokens","Boolean","customBases","customBasesA","address","customBasesB","findIndex","equals","allPairs","Object","values","result","EXISTS","reduce","memo","curr","liquidityToken","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","length","bestTradeExactIn","maxHops","maxNumResults","useTradeExactOut","currencyIn","currencyAmountOut","bestTradeExactOut"],"mappings":"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","sourcesContent":["import { Currency, CurrencyAmount, Pair, Token, Trade } from '@bscswap/sdk'\nimport flatMap from 'lodash.flatmap'\nimport { useMemo } from 'react'\n\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants'\nimport { PairState, usePairs } from '../data/Reserves'\nimport { wrappedCurrency } from '../utils/wrappedCurrency'\n\nimport { useActiveWeb3React } from './index'\n\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n  const { chainId } = useActiveWeb3React()\n\n  const bases: Token[] = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []\n\n  const [tokenA, tokenB] = chainId\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n    : [undefined, undefined]\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      [\n        // the direct pair\n        [tokenA, tokenB],\n        // token A against all bases\n        ...bases.map((base): [Token | undefined, Token | undefined] => [tokenA, base]),\n        // token B against all bases\n        ...bases.map((base): [Token | undefined, Token | undefined] => [tokenB, base]),\n        // each base against all bases\n        ...flatMap(bases, (base): [Token, Token][] => bases.map(otherBase => [base, otherBase]))\n      ]\n        .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n        .filter(([tokenA, tokenB]) => {\n          if (!chainId) return true\n          const customBases = CUSTOM_BASES[chainId]\n          if (!customBases) return true\n\n          const customBasesA: Token[] | undefined = customBases[tokenA.address]\n          const customBasesB: Token[] | undefined = customBases[tokenB.address]\n\n          if (!customBasesA && !customBasesB) return true\n\n          if (customBasesA && customBasesA.findIndex(base => tokenB.equals(base)) === -1) return false\n          if (customBasesB && customBasesB.findIndex(base => tokenA.equals(base)) === -1) return false\n\n          return true\n        }),\n    [tokenA, tokenB, bases, chainId]\n  )\n\n  const allPairs = usePairs(allPairCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {})\n      ),\n    [allPairs]\n  )\n}\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useTradeExactIn(currencyAmountIn?: CurrencyAmount, currencyOut?: Currency): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      return (\n        Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 3, maxNumResults: 1 })[0] ?? null\n      )\n    }\n    return null\n  }, [allowedPairs, currencyAmountIn, currencyOut])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useTradeExactOut(currencyIn?: Currency, currencyAmountOut?: CurrencyAmount): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      return (\n        Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 3, maxNumResults: 1 })[0] ??\n        null\n      )\n    }\n    return null\n  }, [allowedPairs, currencyIn, currencyAmountOut])\n}\n"]},"metadata":{},"sourceType":"module"}